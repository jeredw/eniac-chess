s cy.op 1a

set a4  2244668800  
set a5  9988776655

# memory values to check that various instructions save and restore
set a10 1010101010
set a12 1111111111
set a12 1212121212 
set a13 1313131313 
set a15 1515151515

# ENIAC-VM for playing chess
# Jonathan Stray and Jered Wierzbicki
# created 2020-3-30 
#
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute,
# and implements all the opcodes. The control cycle design is adapted from 
# "Central Control for ENIAC", Adele Goldstine, 1947
#
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

include macros.easm


# -- ACCUMULATOR LAYOUT --
# Defines all accumulators and patches to and from data trunks
# That patching encodes the possible permutations on acc inputs and outputs,
# as well as digit-to-program triggers for discrimination and 1-of-N decoding.
# Listed centrally here to make it easier to track allocation.

# Main data bus, used for most transfers
{d-main}=1

# - Program counter -
# Layout: SS RRRR PPPP
# Current program counter PPPP and return address RRRR, plus a temp SS used for op decode
# Four digit address is FFLL: FF = which ft (09=ft1, 90=ft2, 99=ft3), LL = ft line

{a-pc}=a1

# A - mp steppers, op<=55
p {a-pc}.A {d-main}

# S - mp steppers, op>55
# Decode needs the digits of the SS field to be swapped.
p {a-pc}.S ad.permute.{ad-swap-pc-ss-digits}
s ad.permute.{ad-swap-pc-ss-digits} 11,9,10,8,7,6,5,4,3,2,1
p ad.permute.{ad-swap-pc-ss-digits} {d-main}

# Note there is no discrimination on PC

# main input
p {d-main} {a-pc}.{i-main}

# shiftl8-ir input: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
p {d-main} ad.s.{ad-pc-shiftl8-ir}.8
p ad.s.{ad-pc-shiftl8-ir}.8 {a-pc}.{i-shiftl8-ir}

# clear A input: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
p {d-exS} ad.permute.{ad-exS-clearA}
s ad.permute.{ad-exS-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-exS-clearA} {a-pc}.{i-exS-clearA}

# loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
p {d-main} ad.d.{ad-pc-loadPC2}.-8
p ad.d.{ad-pc-loadPC2}.-8 {a-pc}.{i-loadPC2}

# loadPC4: SS RRRR PPPP -> 00 0000 PPPP, used for JMP FAR/JSR
p {d-main} ad.d.{ad-pc-loadPC4}.-6
p ad.d.{ad-pc-loadPC4}.-6 {a-pc}.{i-loadPC4}


# Several sequences will want to load pc from the main bus so share that
# program via pulse amp
defmacro loadpc prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {a-pc}.{r-loadpc}i
endmacro
s {a-pc}.op{r-loadpc} {i-main}


# - Instruction Register -
# Layout: P I6 I5 I4 I3 I2
# Holds up to 5 instructions queued to execute after loading from a function
# table line. Fills in 99 from the left as instructions are executed. When empty, 
# this will be 9999999999 and then +1 flips to M0, easy to detect
# So we use the sign of IR to decide whether we need to fetch (discriminate on IR)

{a-ir}=a2

# A(11) - discrimination, A(10-1) main
p {a-ir}.A {d-irA}
# Because our PM output lines trigger programs, we don't want to get
# signals back on them from the main bus, so we don't connect sign to main
p {d-irA} ad.permute.{ad-drop-ir-sign}
s ad.permute.{ad-drop-ir-sign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-drop-ir-sign} {d-main}

# S output to its own bus, unpermuted
p {a-ir}.S {d-irS}

# main input
p {d-main} {a-ir}.{i-main}

# fetch input: from d-fetch, used for loading new line of instructions permuted from function table
p {d-fetch} {a-ir}.{i-fetch}

# fill99 input: replace top 2 digits of IR with 99, clear P/M
# the 99 comes from a constant M00000, the rest from EX sent on main
p {d-main} ad.permute.{ad-fill99-main}
s ad.permute.{ad-fill99-main} 0,11,11,8,7,6,5,4,3,2,1
p ad.permute.{ad-fill99-main} {a-ir}.{i-fill99}


# - Execution Register -
# Empty at the beginning of every opcode program
# Typically the only temp space in the machine, so used extensively to save
# contents of other accumulators while they are used functionally
# Also used to disc opcode >55

{a-ex}=a3

# A(11) - discrimination, A(10-1) main
p {a-ex}.A {d-exA}
p {d-exA} ad.permute.{ad-drop-ex-sign}
s ad.permute.{ad-drop-ex-sign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-drop-ex-sign} {d-main}

# S - exS
p {a-ex}.S {d-exS}

# AS - discriminate opcode > 55

# main
p {d-main} {a-ex}.{i-main}

# rotate-ir input: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2 for control cycle
# Shift the instructions right, then we execute and clear I1, removing one from the queue
p {d-main} ad.permute.{ad-ir}
s ad.permute.{ad-ir} 11,2,1,10,9,8,7,6,5,4,3
p ad.permute.{ad-ir} {a-ex}.{i-rotate-ir}

# clearA input: XX XX XX XX XX -> 00 XX XX XX XX, used for MOV X,A and other writes to A
p {d-main} ad.permute.{ad-clearA}
s ad.permute.{ad-clearA} 11,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-clearA} {a-ex}.{i-clearA}

# clearPC2: SS RRRR PPPP -> SS RRRR PP00, used for JMP/JN/JZ/JIL
p {d-main} ad.permute.{ad-clearPC2}
s ad.permute.{ad-clearPC2} 11,10,9,8,7,6,5,4,3,0,0
p ad.permute.{ad-clearPC2} {a-ex}.{i-clearPC2}

# clearPC4: SS RRRR PPPP -> SS RRRR 0000, used for JMP FAR/JSR/RET
p {d-main} ad.permute.{ad-clearPC4}
s ad.permute.{ad-clearPC4} 11,10,9,8,7,6,5,0,0,0,0
p ad.permute.{ad-clearPC4} {a-ex}.{i-clearPC4}


# predefine programs that load ex from and store ex to main -- we use these everywhere
# go through pulseamps so other uses don't flow backwards
defmacro loadex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{r-loadex}i
endmacro
s {a-ex}.op{r-loadex} {i-main}

# sends EX to main and clears
defmacro storeex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{t-storeex}i
endmacro
s {a-ex}.op{t-storeex} A
s {a-ex}.cc{t-storeex} C


# - Register File -
# Registers A-E of the virtual machine. A is our accumulator.
{a-rf}=a4
p {a-rf}.A {d-main}

p {d-main} {a-rf}.{i-main}

# i-clearA, for CLR A
p {d-main} ad.d.{ad-rf-clearA}.-2
p ad.d.{ad-rf-clearA}.-2 {a-rf}.{i-clearA}

# i-shiftl8, for getting operands into A for MOV #XX,A 
p {d-main} ad.s.{ad-rf-shiftl8}.8
p ad.s.{ad-rf-shiftl8}.8 {a-rf}.{i-shiftl8}

# load/store macros
$recx {p-loadrf} {a-rf} {r-loadrf} {i-main}
defmacro loadrf prog
  $pulseamp $prog {p-loadrf}
endmacro

defmacro storerf prog
  $pulseamp $prog {a-rf}.{r-storerf}i
endmacro
s {a-rf}.op{r-storerf} A
s {a-rf}.cc{r-storerf} C


# - Load/Store -
# Registers F-J of the virtual machine. 
{a-ls}=a5

p {a-ls}.A {d-main}

p {d-main} {a-ls}.{i-main}


# - MEM4 -
# Used for swap A,BCDE and storeacc 0-9
{a-mem4}=a10
{a-swapBCDE}=a10

p {a-mem4}.A {d-main}

p {d-main} {a-mem4}.{i-main}

p {d-main} ad.permute.{ad-swapAB}
s ad.permute.{ad-swapAB} 11,8,7,10,9,6,5,4,3,2,1
p ad.permute.{ad-swapAB} {a-swapBCDE}.{i-swapAB}

p {d-main} ad.permute.{ad-swapAC}
s ad.permute.{ad-swapAC} 11,6,5,8,7,10,9,4,3,2,1
p ad.permute.{ad-swapAC} {a-swapBCDE}.{i-swapAC}

p {d-main} ad.permute.{ad-swapAD}
s ad.permute.{ad-swapAD} 11,4,3,8,7,6,5,10,9,2,1
p ad.permute.{ad-swapAD} {a-swapBCDE}.{i-swapAD}

p {d-main} ad.permute.{ad-swapAE}
s ad.permute.{ad-swapAE} 11,2,1,8,7,6,5,4,3,10,9
p ad.permute.{ad-swapAE} {a-swapBCDE}.{i-swapAE}

# load/store using t- because out of r-
# TODO do these need to be reused still?
$recx {p-load-swapBCDE} {a-swapBCDE} {t-load-swapBCDE} {i-main}
$sendcx {p-store-swapBCDE} {a-swapBCDE} {t-store-swapBCDE} A


# - MEM6 -
# Discriminate LOADACC < 10
# Also has shift inputs and programs for shifting the PC for JSR/RET.
{a-mem6}=a12
{a-shiftpc}=a12

# A output to main
p {a-mem6}.A {d-main}

# main input: d-main
p {d-main} {a-mem6}.{i-main}

# extract-pc input: XX XX XX PP PP -> 00 00 00 PP PP
p {d-main} ad.permute.{ad-extract-pc}
s ad.permute.{ad-extract-pc} 0,0,0,0,0,0,0,4,3,2,1
p ad.permute.{ad-extract-pc} {a-shiftpc}.{i-extract-pc}

# shiftr4-pc input: shift XX RRRR PPPP to 00 0000 RRRR
p {d-main} ad.permute.{ad-shiftr4-pc}
s ad.permute.{ad-shiftr4-pc} 0,0,0,0,0,0,0,8,7,6,5
p ad.permute.{ad-shiftr4-pc} {a-shiftpc}.{i-shiftr4-pc}

# shiftl4-pc input: shift XX XXXX PPPP to XX PPPP 0000
p {d-main} ad.permute.{ad-shiftl4-pc}
s ad.permute.{ad-shiftl4-pc} 0,0,0,4,3,2,1,0,0,0,0
p ad.permute.{ad-shiftl4-pc} {a-shiftpc}.{i-shiftl4-pc}


# - MEM7 - 
# MEM7 is a13 and is used for printing, has an input that shifts AB into printing position
{a-mem7}=a13
{a-print}=a13
p {a-mem13}.A {d-main}

p {d-main} {a-mem7}.{i-main}

p {d-main} ad.permute.{ad-printAB}
s ad.permute.{ad-printAB} 11,0,10,9,8,7,0,0,0,0,0
p ad.permute.{ad-printAB} {a-mem7}.{i-printAB}


# - MEM9 -
# Used for JN
{a-mem9}=a15
{a-discjn}=a15

# A to its own bus
p {a-discjn}.A {d-discjnA}

# Discriminator; need to delete sign when going from A to main
p {d-discjnA} ad.permute.{ad-discjnA-sign}
s ad.permute.{ad-discjnA-sign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-discjnA-sign} {d-main}

# S to its own bus
p {a-discjn}.S {d-discjnS}

# main input
p {d-main} {a-mem9}.{i-main}


# - MEM10 -
{a-mem10}=a16
{a-dummy4}=a16


# - MEM11 -
{a-mem11}=a17
{a-store09}=a17

# third set of dummies here, outside of FTSG selection logic, so it can used there
{a-dummy3}=a17


# - MEM12 -
{a-mem12}=a18


# - MEM13 -
{a-mem13}=a19
{a-dummy2}=a20


# - MEM14 -
{a-mem14}=a20
{a-dummy}=a20


# - Function table decode -
# Uses 18,19,20
{a-discft1}=a18
{a-discft2}=a19
{a-discft3}=a20

# The PM digits of M18, M19, and M20 select the current function table for
# instruction fetch. They also have programs to decode the FTSG field.
defmacro discftaccum name dummy ftnum
  p {a-$name}.A {d-main}

  # S.PM is wired to a dummy program to trigger an FT
  p {a-$name}.S ad.dp.{ad-$name-discft$ftnum}.11
  p ad.dp.{ad-$name-discft$ftnum}.11 {a-$dummy}.{t-$name-S}i
  s {a-$dummy}.op{t-$name-S} 0
  p {a-$dummy}.{t-$name-S}o {p-trigger-ft$ftnum}

  # i-main from main bus
  p {d-main} {a-$name}.{i-main}

  # i-ftsg1 puts the ftsg1 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg1}
  s ad.permute.{ad-$name-ftsg1} 3,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg1} {a-$name}.{i-ftsg1}

  # i-ftsg2 puts the ftsg2 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg2}
  s ad.permute.{ad-$name-ftsg2} 4,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg2} {a-$name}.{i-ftsg2}
endmacro

# Strictly speaking only discft3 needs both i-ftsg1 and i-ftsg2 inputs but we
# are not constrained on inputs for these accumulators.
$discftaccum discft1 discft2 1
$discftaccum discft2 discft3 2
$discftaccum discft3 discft1 3

# discft1 is also used to form intitial PC address on reset
# resetPC input: takes M0 from bus, sets initial PC to 0900
p {d-main} ad.permute.{ad-pc-reset}
s ad.permute.{ad-pc-reset} 0,0,0,0,0,0,0,0,11,0,0
p ad.permute.{ad-pc-reset} {a-discft1}.{i-resetPC}




# - Constant transmitter -
# So that we can use all the constant switches, connect both the left and the
# right 5 constant digits to the leftmost wires of d-main where they're needed.
# This is perhaps electrically questionable, but should work?  Provided the
# right constants are positive, there should be no bus conflicts - if they were
# negative, the constant transmitter would also drive 9s onto the same wires
# for sign extension.
p c.o ad.permute.{ad-constant-left}
s ad.permute.{ad-constant-left} 11,10,9,8,7,6,0,0,0,0,0
p ad.permute.{ad-constant-left} {d-main}
p c.o ad.permute.{ad-constant-right}
# (Delete sign so that eniacsim doesn't send two copies of the sign pulses...)
s ad.permute.{ad-constant-right} 0,5,4,3,2,1,0,0,0,0,0
p ad.permute.{ad-constant-right} {d-main}

# M99000 used in control cycle, DEC
s c.jl  M
s c.j10 9
s c.j9  9

# M00000 used in control cycle to fill consumed op with 99, machine reset
s c.kl  M
s c.k10 0
s c.k9  0

# whenever you need a 9 on the bus, call sendM0 (goes through a pulseamp)
defmacro sendM0 prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} c.25i
endmacro
s c.s25 Kl

# P43000 used in control cycle, to test opcode > 55. 43 = 99-55-1
s c.kr P
s c.k5 4
s c.k4 3

# P01000 used in control cycle, INC
s c.jr P
s c.j5 0
s c.j4 1


# - Setup MP as an opcode decoder -
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6

# This switch setting makes eniacsim disable/disassociate MP decade counters.
#
# Decade counters are a problem for decoding because they trigger a spurious
# extra step whenever they overflow, and they count in a data-dependent way on
# each program input (e.g. p.Ai, p.Bi, ...). Possibly some scheme could be
# devised to guarantee decade counters are safe before p.Ai for decode - they
# don't have an explicit clear control, but do clear on overflow.  But it's far
# simpler just to unplug the things.
#
# Associator switches on the MP front panel don't permit disconnecting decade
# counters, but the operating manual notes "To disassociate a decade from its
# stepper pull out gate tube 63 in the stepper plug-in unit. See block diagram
# PX-8-304."
s p.gate63 unplug

# Receive opcode at master programmer stepper direct inputs
p {d-main} ad.dp.{ad-opcode-10}.10   # opcode 10's digit (0x-5x)
p ad.dp.{ad-opcode-10}.10 p.Adi
p {d-main} ad.dp.{ad-opcode-9}.9     # opcode 1's digit (0x-5x)
p ad.dp.{ad-opcode-9}.9 p.Bdi
p ad.dp.{ad-opcode-9}.9 p.Cdi
p ad.dp.{ad-opcode-9}.9 p.Ddi
p ad.dp.{ad-opcode-9}.9 p.Edi
p ad.dp.{ad-opcode-9}.9 p.Fdi
p ad.dp.{ad-opcode-9}.9 p.Gdi        # opcode 1's digit (0x-5x) or 10's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Hdi      # opcode 1's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Jdi
p ad.dp.{ad-opcode-10}.10 p.Kdi

# Trigger the appropriate ones digit for opcodes <= 55
p p.A1o p.Bi
p p.A2o p.Ci
p p.A3o p.Di
p p.A4o p.Ei
p p.A5o p.Fi
p p.A6o {p-mp-5x}

# For opcodes>55, Gi is triggered both by A6o when decoding 5x, and explicitly via a program
# control to decode the tens digit of 7x-9x.
$pulseamp {p-mp-5x} p.Gi
$pulseamp {p-mp-789x} p.Gi


# Wire the outputs to individual opcode programs
# outputs rotated with respect to digits as we decode I1+1
defmacro op-lines-le55 stepper tens
  p p.$stepper1o {p-op$tens5}
  p p.$stepper2o {p-op$tens0}
  p p.$stepper3o {p-op$tens1}
  p p.$stepper4o {p-op$tens2}
  p p.$stepper5o {p-op$tens3}
  p p.$stepper6o {p-op$tens4}
endmacro

$op-lines-le55 B 0
$op-lines-le55 C 1
$op-lines-le55 D 2
$op-lines-le55 E 3
$op-lines-le55 F 4
# G1o-G3o are used for 7x-9x.
p p.G4o {p-op52}
p p.G5o {p-op53}
p p.G6o {p-op54}

# Trigger the appropriate ones digit for opcodes >= 70.
p p.G1o p.Hi
p p.G2o p.Ji
p p.G3o p.Ki

# Rotated because we decode on PC.S for op>55, so this is 99-(OP+1) = 100-OP.
# TODO Confirm MP steppers increment from 6 to 1 - we're assuming so here for
# nicer opcode numbering.
defmacro op-lines-gt55 stepper tens
  p p.$stepper1o {p-op$tens2}
  p p.$stepper2o {p-op$tens1}
  p p.$stepper3o {p-op$tens0}
  p p.$stepper4o {p-op$tens5}
  p p.$stepper5o {p-op$tens4}
  p p.$stepper6o {p-op$tens3}
endmacro

$op-lines-gt55 H 9
$op-lines-gt55 J 8
$op-lines-gt55 K 7

# -- RESET --
# Builtin clearing should first set all accumulators to 0
p i.io {p-reset}

# Reset PC, IR, and initial ft selector accumulators
# Send M00000
$sendM0 {p-reset}

# Set discft2/discft3 signs to M so that ft1 is selected via discft1.PM = P
$rec {p-reset} {a-discft2} {t-reset} {i-main} {p-reset-2}
$recx {p-reset} {a-discft3} {r-reset} {i-main}

# IR to M0 so we trigger a fetch
$recx {p-reset} {a-ir} {r-reset} {i-main}

# Set discft1 to 0900 which is the initial PC, then copy to PC (out of PC inputs)
$recx {p-reset} {a-discft1} {t-reset} {i-resetPC}

# Reset PC from discft1 and clear discft1
$sendc {p-reset-2} {a-discft1} {t-reset-2} A {p-fetch}
$loadpc {p-reset-2}


# -- CONTROL CYCLE --

# - A program line to jump to if ex has something in it
$clear {p-clearex-fetch} {a-ex} {t-clearex-fetch} {p-fetch}


# -- p-fetch: begin next instruction
# During this cycle:
#  - discriminate, to decide whether to fetch new instructions, clear IR
#  - read out the contents of IR into EX
#  - send next instruction (I1) to PC (assume PC.SS is 0)
$assert {p-fetch} {a-ex}~P0000000000
$assert {p-fetch} {a-pc}~x00xxxxxxxx

# If more instructions are needed, IR is M0, and control proceeds to p-fetchline.
# Otherwise, IR is P I5 I4 I3 I2 I1+1 and we trigger p-nofetch-eat-op.
$discriminatec {p-fetch} {a-ir} {a-dummy} fetch {d-irA} {d-irS} {p-nofetch-eat-op} {p-fetchline} 

# IR -> EX 
# $discriminate sends IR on d-main, and EX receives it permuted I5 I4 I3 I2 I1+1
# -> I1+1 I5 I4 I3 I2.  This puts the next instruction in the left (first two
# digits) of EX. 
$recx {p-fetch} {a-ex} {r-fetch} {i-rotate-ir}

# IR -shiftl8-ir-> PC
# Also send first opcode to left of PC. This copy of the instruction will later be
# sent to MP steppers for decoding.
$recx {p-fetch} {a-pc} {r-fetch} {i-shiftl8-ir}



# -- {p-nofetch} no fetch needed, begin instruction decode
$pulseamp {p-nofetch-eat-op} {p-nofetch}
# PC has I1+1 at left
# EX is P I1+1 I5 I4 I3 I2
$assert {p-nofetch} {a-ex}~Pxxxxxxxxxx

# Begin decode by adding 43 to EX, from constant transmitter

# Send 43 from CT on d-main
p {p-nofetch} c.26i 
s c.s26 Kr

# EX += 43 for discrimination next cycle
# EX = I1+1
# If I1 <= 55 then I1+1+43 < 100, EX still P
# If I1 > 55 then I1+1+43 >= 100, EX now M
$rec {p-nofetch} {a-ex} {t-nofetch} {i-main} {p-disc-op}

# If we are eating an operand (removing it from IR) then we need to set
# the top digits of IR to 99 after next instruction (delay 1 cycle)
$dummy {p-nofetch-eat-op} {a-dummy} {t-eat-op} 1 {p-eat-op}


# -- {p-disc-op} discriminate opcode I1>55, to switch between two decode pathways
# EX starts P/M I1+44 I5 I4 I3 I2 and ends clear.
# Also store I5..I2 back to IR, replacing just-dispatched opcode with 99 if p-eat-op.
$assert {p-eat-op} {a-ir}~P0000000000

# Discriminate based on sign of EX, already set based on whether I1 > 55. Clear EX.
$discriminatec {p-disc-op} {a-ex} {a-dummy} disc-op {d-exA} {d-exS} {p-ople55} {p-opgt55}

# If we are consuming from IR, store EX back into IR without the op we are now decoding.
# Replace first two digits with M from a constant, so the top of IR is
# P99. Finally, increment so that an empty IR, P9999999999, wraps to M0000000000.
# This also turns I2 into I2+1 at the right of IR.
$recincx {p-eat-op} {a-ir} {t-disc-op} {i-fill99}
# Send M00000 from the constant transmitter to fix IR.  EX doesn't send a sign
# on d-main so there's no bus conflict.
$sendM0 {p-eat-op}

# Clear MP prior to decode.  Clearing isn't synchronous, so this needs to
# happen "next cycle" i.e. during pulse 17 of p-disc-op.
$dummy {p-disc-op} {a-dummy} {t-disc-op} 1 {p-clear-mp}
p {p-clear-mp} p.Acdi
p {p-clear-mp} p.Bcdi
p {p-clear-mp} p.Ccdi
p {p-clear-mp} p.Dcdi
p {p-clear-mp} p.Ecdi
p {p-clear-mp} p.Fcdi
p {p-clear-mp} p.Gcdi
p {p-clear-mp} p.Hcdi
p {p-clear-mp} p.Jcdi
p {p-clear-mp} p.Kcdi


# -- p-ople55 - send tens digit of opcode to stepper A, ones digit to B-G
# Also PC->EX to begin clearing SS 
$assert {p-ople55} {a-ex}~P0000000000

# Send PC on main and receive in EX with SS (opcode field) clear.
$sendc {p-ople55} {a-pc} {t-ople55} A {p-ople55-2}
$recx {p-ople55} {a-ex} {r-ople55} {i-clearA}


# -- p-ople55-2 - send input pulse to master programmer
# sign of EX must be P to avoid misfiring p-ople55
$assert {p-ople55-2} {a-pc}~P0000000000
$assert {p-ople55-2} {a-ex}~P00xxxxxxxx

# Send EX back to PC with opcode field clear to prep for instruction.
# Note that this would trigger the MP steppers, but the opcode field contains
# 00 here so this doesn't mess up decode.
$sendcx {p-ople55-2} {a-ex} {t-ople55-2} A
$loadpc {p-ople55-2}

# Trigger master programmer
p {p-ople55-2} p.Ai


# -- p-opgt55 - send tens digit to mp G stepper, ones digit to H-K
$assert {p-opgt55} {a-ex}~P0000000000

# Send PC subtractively on main, stepping the MP, and receiving in EX.
# Note that EX receives the 10's complement of PC, so will include an extra +1
# from the 1pp. This is undone when sending EX back to PC subtractively next
# cycle.
$sendc {p-opgt55} {a-pc} {t-opgt55} S {p-opgt55-2}
$loadex {p-opgt55}


# -- p-opgt55-2 - send input pulse to master programmer
# Sign of EX must be M to avoid misfiring p-ople55 (triggered from a-ex.S sign)
$assert {p-opgt55-2} {a-ex}~Mxxxxxxxxxx

# EX back to PC, with opcode field (SS) cleared
# Note #1: This is arithmetically incorrect. PC receives the 9's complement of
# EX with 0s in the opcode field, then an extra +1 from the 1pp. If PC were
# Pxx00000000, this would give P0099999999 and the 1pp would cause a carry into
# the opcode field leaving it P01... instead of P00. That can't happen because
# PC.RRRR always begins with 09, 90, or 99, so there's no possibility of a
# carry into digit 9.
# Note #2: EX.S is not connected to d-main. If it were, this would cause
# spurious MP inputs.
$sendcx {p-opgt55-2} {a-ex} {r-opgt55-2} S
$recx {p-opgt55-2} {a-pc} {r-opgt55-2} {i-exS-clearA}

# Trigger master programmer.
p {p-opgt55-2} {p-mp-789x}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# Trigger the currently selected FT to send
$send {p-fetchline} {a-discft1} {t-fetchline} S {p-fetchtrig}
$sendx {p-fetchline} {a-discft2} {r-fetchline} S
$sendx {p-fetchline} {a-discft3} {r-fetchline} S

# FT settings
defmacro triggerft num
  p {p-trigger-ft$num} f$num.1i
  s f$num.rp1 1                    # send once in r-fetchread
  s f$num.op1 A0                   # send uncomplemented, don't offset argument
  s f$num.cl1 C                    # pulse on C when done
  p f$num.C {p-fetcharg}           # goto when ready for argument
endmacro
$triggerft 1
$triggerft 2
$triggerft 3


# -- {p-fetchtrig}
# FT is "stimulated" in this cycle, from discft1-3 S output
# It will trigger p-fetcharg next cycle to get line index
# Meanwhile, clear IR (needed only on jumps, otherwise already zero here from overflow)
# Also use this clear to trigger read from FT, 4 cycles from now

$clear {p-fetchtrig} {a-ir} {t-fetchtrig} {p-fetchread}
s {a-ir}.rp{t-fetchtrig} 4    # repeat 4 to wait for FT result


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)
$send {p-fetcharg} {a-pc} {t-fetcharg} A {p-preinc-fetch}
p {d-main} f1.arg  # only bottom two digit lines connect so no deleter is required
p {d-main} f2.arg
p {d-main} f3.arg


# -- {p-preinc-fetch} preincrement left field of EX and PC
$assert {p-preinc-fetch} {a-ex}~P0000000000
$assert {p-preinc-fetch} {a-pc}~P00xxxxxxxx

# Send P01000 from the constant transmitter
p {p-preinc-fetch} c.28i
s c.s28 Jr

# Preload P01 into EX and PC so that when the FT sends I1, EX and PC will end
# up I1+1 which is the precondition in p-nofetch.
$loadex {p-preinc-fetch}
$loadpc {p-preinc-fetch}


# -- {p-fetchread} read ft line of instructions
#  - FT sends uncomplemented instructions on A and B
#  - IR = P I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = P I1+1 00 00 00 00 = A6A5+1 00 00 00 00
#  - PC = P I1+1 xx xx xx PC+1

# B2B1 B4B3 B6B5 A2A1 A4A3 -> IR
p f1.A {d-fA}
p f2.A {d-fA}
p f3.A {d-fA}
p {d-fA} ad.permute.{ad-fetchA}
s ad.permute.{ad-fetchA} 0,0,0,0,0,0,0,2,1,4,3
p ad.permute.{ad-fetchA} {d-fetch}

p f1.B ad.permute.{ad-fetchB}
p f2.B ad.permute.{ad-fetchB}
p f3.B ad.permute.{ad-fetchB}
s ad.permute.{ad-fetchB} 11,2,1,4,3,6,5,0,0,0,0
p ad.permute.{ad-fetchB} {d-fetch}

# Increment IR to make the rightmost instruction I2+1 instead of I2
$recincx {p-fetchread} {a-ir} {r-fetchread} {i-fetch}

# A6A5 00 00 00 00 -> EX,PC
p {d-fA} ad.permute.{ad-fetch-ex}
s ad.permute.{ad-fetch-ex} 11,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-fetch-ex} {d-main}

# Get I1+1 in the top of EX and PC, and increment PC
$loadex {p-fetchread}
$recinc {p-fetchread} {a-pc} {t-fetchread} {i-main} {p-nofetch}



# -- MICRO-SUBROUTINES --
# Sequences shared between instructions, none of which retrigger the main cycle

# - CONSUME-OP -
# Consume opcode: used to read immediate operands
# Sends IR on first cycle, I1 can be read off as needed
# Rotates IR back to EX, shifts right, places 99 at left, adds 1
# This mimics how the control cycle works in microcosm

defmacro consume-op prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {p-sub-consume-op}
endmacro

$assert {p-sub-consume-op} {a-ir}~Pxxxxxxxxxx  # so fetch/nofetch discrim does not trigger

# IR -rotate-r-> EX
$sendc {p-sub-consume-op} {a-ir} {t-consume-op} A {p-sub-consume-op-2}
$recx {p-sub-consume-op} {a-ex} {t-consume-op} {i-rotate-ir}  # out of recievers

# EX -fill99-> IR 
# Put shifted instructions back in IR, filling top with 99, +1 to detect IR empty
$storeex {p-sub-consume-op-2}
$recincx {p-sub-consume-op-2} {a-ir} {r-consume-op-2} {i-fill99}

# fill99 requires an M0 on the bus
$sendM0 {p-sub-consume-op-2}


# - JMP -
# Short jump (2 digits, no FT switch) to immediate operand

defmacro jmp prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {p-sub-jmp}
endmacro

# Clear lower digits of PC (not ftsg, this is a near jump)
# PC -clearPC2-> EX
$sendc {p-sub-jmp} {a-pc} {t-sub-jmp} A {p-sub-jmp-2}
$recx {p-sub-jmp} {a-ex} {t-sub-jmp} {i-clearPC2} 

# EX -> PC
$storeex {p-sub-jmp-2}
$rec {p-sub-jmp-2} {a-pc} {t-sub-jmp-2} {i-main} {p-sub-jmp-3}

# Copy next word in IR to PC, then fetchline. Because we jump, don't need to update IR
$sendx {p-sub-jmp-3} {a-ir} {r-send} A
$rec {p-sub-jmp-3} {a-pc} {t-sub-jmp-3} {i-loadPC2} {p-fetchline} 


# - DISCFT -
# The common receive portion of the sequence to select ft from PC ftsg
# Note that applying this twice is a NOP. So for far jumps (JMP FAR/JSR/RET)
# we invoke once with current PC, then update FTSG, and call again.

defmacro discft prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-discft}
endmacro

# Decode discft1 and discft2 signs
$recx {p-sub-discft} {a-discft1} {r-sub-discft} {i-ftsg2}
$rec {p-sub-discft} {a-discft2} {t-sub-discft} {i-ftsg1} {p-sub-discft-2}
$recx {p-sub-discft} {a-discft3} {r-sub-discft} {i-ftsg1}

# Finish decoding discft3 sign
$recx {p-sub-discft-2} {a-discft3} {r-sub-discft-2} {i-ftsg2}


# - STARTJMP -
# Send PC twice and then clear it to load new PC, meanwhile deselecting current FT
defmacro startjmp prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-startjmp}
endmacro

$sendcx {p-sub-startjmp} {a-pc} {t-sub-startjmp} A
s {a-pc}.rp{t-sub-startjmp} 2
$discft {p-sub-startjmp}


# - FINISHJMP -
# Send shiftpc twice, load pc, meanwhile selecting new ft, and then go to fetch
defmacro finishjmp prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-finishjmp}
endmacro

# Send shiftpc twice for discft to select new function table
$sendc {p-sub-finishjmp} {a-shiftpc} {t-sub-finishjmp} A {p-sub-finishjmp-3}
s {a-shiftpc}.rp{t-sub-finishjmp} 2
$discft {p-sub-finishjmp}
$loadpc {p-sub-finishjmp}

# Restore shiftpc from ex in parallel with p-fetchline
$storeex {p-sub-finishjmp-3}
$recx {p-sub-finishjmp-3} {a-shiftpc} {r-sub-finishjmp-3} {i-main}
$pulseamp {p-sub-finishjmp-3} {p-fetchline}


# -- OPCODE IMPLEMENTATIONS --

#$break {p-op00}  # NOP
#$break {p-op01}  # SWAP A,B
#$break {p-op02}  # SWAP A,C
#$break {p-op03}  # SWAP A,D
#$break {p-op04}  # SWAP A,E
#$break {p-op10}  # LOADACC
#$break {p-op12}  # SWAPALL
#$break {p-op35}  # CLR A
#$break {p-op40}  # MOV #xx,A
#$break {p-op52}  # INC A
#$break {p-op53}  # DEC A
#$break {p-op73}  # JMP xx
#$break {p-op74}  # JMP xxxx
#$break {p-op80}  # JN xx
#$break {p-op84}  # JSR xxxx
#$break {p-op85}  # RET
#$break {p-op92}  # PRINT
#$break {p-op95}  # HALT


# - NOP -
p {p-op00} {p-fetch}


# - LOADACC -
p {p-op10} {p-oploadacc}

#  4. EX -> DISCLOADACC, clear
#  5. LOAD09 -> EX, clear
#  6. receive A,B into LOAD09
#  7. send LOAD09 on S, clear                  ; trigger one acc to transmit
#  8  main -> LS
#  9. EX -> LOAD09, clear   

# - SWAPALL -
# Exchange RF and LS. Nothing fancy here.
p {p-op12} {p-opswapall}

# RF->EX
$sendc {p-opswapall} {a-rf} {t-opswapall} A {p-opswapall-2}
$loadex {p-opswapall}

# LS->RF
$sendc {p-opswapall-2} {a-ls} {t-opswapall-2} A {p-opswapall-3}
$loadrf {p-opswapall-2}

# EX->LS
$storeex {p-opswapall-3}
$rec {p-opswapall-3} {a-ls} {t-opswapall-3} {i-main} {p-fetch}


# - SWAP A,[BCDE] -
# First two cycles of each instruction is per-op, last two cycles shared
# 1. per-op: swapBCDE->EX
# 2. per-op: RF-swapA[BCDE]->swapBCDE, this is where the actual swap is
# 3. shared: swapBCDE->RF
# 4. shared: EX->swapBCDE
# Use 7 transceivers (6 on swapBCDE + 1 dummy) and 11 programs total, leaving 2
# transceivers free for load/store on swapBCDE.  Using transceivers for
# p-opswap-Ax-2 programs would need only 10 programs total (8 on swapBCDE + 2
# dummies) but this way uses one fewer dummy.

p {p-op01} {p-opswapAB}
p {p-op02} {p-opswapAC}
p {p-op03} {p-opswapAD}
p {p-op04} {p-opswapAE}

# Dummy to trigger shared program in cycle 3
$pulseamp {p-opswapAB} {p-opswapXX}
$pulseamp {p-opswapAC} {p-opswapXX}
$pulseamp {p-opswapAD} {p-opswapXX}
$pulseamp {p-opswapAE} {p-opswapXX}
$dummy {p-opswapXX} {a-dummy2} {t-opswapXX} 2 {p-opswapBCDE}

defmacro swapBCDE-op reg
  # swapBCDE->EX, save swapBCDE
  $sendc {p-opswapA$reg} {a-swapBCDE} {t-swapA$reg} A {p-opswapA$reg-2}
  $loadex {p-opswapA$reg}

  # RF->swapBCDE, on swap input -- actually does the swap
  $storerf {p-opswapA$reg-2}
  $recx {p-opswapA$reg-2} {a-swapBCDE} {r-opswapA$reg-2} {i-swapA$reg}
endmacro
$swapBCDE-op B
$swapBCDE-op C
$swapBCDE-op D
$swapBCDE-op E

# swapBCDE->RF, saves swapped values back to RF
$sendc {p-opswapBCDE} {a-swapBCDE} {t-opswapBCDE} A {p-opswapBCDE-2}
$loadrf {p-opswapBCDE}

# EX->swapBCDE, restore swapBCDE
$storeex {p-opswapBCDE-2}
$rec {p-opswapBCDE-2} {a-swapBCDE} {t-opswapBCDE-2} {i-main} {p-fetch}


# - CLR A -
# RF -> EX
$sendc {p-op35} {a-rf} {t-op35} A {p-op35-2}
$loadex {p-op35}

# EX -clearA-> RF
$storeex {p-op35-2}
$rec {p-op35-2} {a-rf} {t-op35-2} {i-clearA} {p-fetch}


# - MOV #XX,A -

# First clear A
# RF -> EX
$sendc {p-op40} {a-rf} {t-op40} A {p-op40-2}
$loadex {p-op40}

# EX -clearA-> RF
$storeex {p-op40-2}
$rec {p-op40-2} {a-rf} {t-op40-2} {i-clearA} {p-op40-3}

# Now consume the next word in IR, saving it into A
$consume-op {p-op40-3}
$recx {p-op40-3} {a-rf} {r-load} {i-shiftl8}    # save lowest word into A

# wait for 2 cycles of consume-op, then next op
$dummy {p-op40-3} {a-dummy3} {t-op40-3} 2 {p-fetch}


# - INC -
# Send P01000 on d-main
p {p-op52} c.29i
s c.s29 Jr

# Increment A field of RF
# XXX should probably use pulseamp
$rec {p-op52} {a-rf} {t-op52} {i-main} {p-fetch}


# - DEC -
# Send M99000 on d-main
p {p-op53} c.30i
s c.s30 Jl

# Decrement A field of RF
# XXX should probably use pulseamp
$rec {p-op53} {a-rf} {t-op53} {i-main} {p-fetch}


# - JMP XX -

p {p-op73} {p-sub-jmp}


# - JMP XXXX -
# This is similar to JSR/RET sequences but saves a cycle by using IR directly
# because there is no need to shift.
# 1. PC -clearPC4-> EX  $discft-1
# 2. send PC            $discft-2
# 3. EX -> PC
# 4. IR -loadPC4-> PC   $discft-1
# 5. send IR            $discft-2

# Deselect current function table
$startjmp {p-op74}
# PC -clearPC4-> EX
$rec {p-op74} {a-ex} {t-op74} {i-clearPC4} {p-op74-2}

$dummy {p-op74-2} {a-dummy3} {t-op74-2} 1 {p-op74-3}  # not a-dummy2 because discft* in use

# EX -> PC
$storeex {p-op74-3}
$loadpc {p-op74-3}
$dummy {p-op74-3} {a-dummy3} {t-op74-3} 1 {p-op74-4}

# Select new function table and go to fetch
$assert {p-op74-4} {a-ir}~Pxxxxxxxxxx  # don't trigger IR discrimination
$send {p-op74-4} {a-ir} {t-op74-4} A {p-fetchline}
s {a-ir}.rp{t-op74-4} 2
$discft {p-op74-4}
# Load new PC
$recx {p-op74-4} {a-pc} {r-op74-4} {i-loadPC4}


# - JSR XXXX -
# 1. SHIFTPC -> EX
# 2. IR -extract-pc-> SHIFTPC
# 3. PC -shiftl4-pc-> SHIFTPC  $discft-1
# 4. send PC                   $discft-2
# 5. SHIFTPC -> PC             $discft-1
# 6. send SHIFTPC              $discft-2
#  . EX -> SHIFTPC             (parallel with p-fetchline)

# Save shiftpc in ex
$sendc {p-op84} {a-shiftpc} {t-op84} A {p-op84-2}
$loadex {p-op84}

# Extract pc from ir into shiftpc
$assert {p-op84-2} {a-ir}~Pxxxxxxxxxx
$sendx {p-op84-2} {a-ir} {t-op84-2} A
$rec {p-op84-2} {a-shiftpc} {t-op84-2} {i-extract-pc} {p-op84-3}

# Deselect ft and load RRRR into PPPP field in shiftpc
$startjmp {p-op84-3}
$rec {p-op84-3} {a-shiftpc} {t-op84-3} {i-shiftl4-pc} {p-op84-4}

$dummy {p-op84-4} {a-dummy3} {t-op84-4} 1 {p-op84-5}

# Select new ft, reload new PC, goto fetchline, restore shiftpc
$finishjmp {p-op84-5}


# - RET -
# 1. SHIFTPC -> EX
# 2. PC -shiftr4-pc-> SHIFTPC  $discft-1
# 3. send PC                   $discft-2
# 4. SHIFTPC -> PC             $discft-1
# 5. send SHIFTPC              $discft-2
#  . EX -> SHIFTPC             (parallel with p-fetchline)

# Save shiftpc in ex
$sendc {p-op85} {a-shiftpc} {t-op85} A {p-op85-2}
$loadex {p-op85}

# Deselect ft and load RRRR into PPPP field in shiftpc
$startjmp {p-op85-2}
$rec {p-op85-2} {a-shiftpc} {t-op85-2} {i-shiftr4-pc} {p-op85-3}

$dummy {p-op85-3} {a-dummy3} {t-op85-3} 1 {p-op85-4}

# Select new ft, reload new PC, goto fetchline, restore shiftpc
$finishjmp {p-op85-4}


# - JN XX -

# save DISCJN
$sendc {p-op80} {a-discjn} {t-op80} A {p-opjn-2}
$loadex {p-op80}

# RF->DISCJN, this puts sign of A into DISCJN PM
$send {p-opjn-2} {a-rf} {t-opjn} A {p-opjn-3} # replace with RF send macro?
$recx {p-opjn-2} {a-discjn} {t-opjn} {i-main}

# discriminate, and clear to ready DISCJN for restored memory value
$discriminatec {p-opjn-3} {a-discjn} {a-dummy3} opjn-3 {d-discjnA} {d-discjnS} {p-opjn-pos} {p-opjn-neg}

# if positive, restore acc, consume and carry on
$storeex {p-opjn-pos}
$rec {p-opjn-pos} {a-discjn} {t-opjn-pos} {i-main} {p-opjn-eat}

$consume-op {p-opjn-eat}
$dummy {p-opjn-eat} {a-dummy4} {t-opjn-eat} 2 {p-fetch}

# if negative, restore acc and jump
$storeex {p-opjn-neg}
$rec {p-opjn-neg} {a-discjn} {t-opjn-neg} {i-main} {p-sub-jmp}


# - PRINT - 
# Save a13, RF-printAB->a13, restore
# Really the only trick here is that we can only print from a13,
# and during the transfer we shift RF right so we print 0AABB not AABBC

# PRINT->EX, clear
$sendc {p-op92} a13 {t-op96} A {p-op92-2}
$loadex {p-op92}

# RF-printAB->a13. Puts AB in lower 4 digits of upper half of accumulator
$sendx {p-op92-2} {a-rf} {r-op92-2} A    
$rec {p-op92-2} a13 {t-printAB} {i-printAB} i.pi # trigger print

# prints high half accumulator 13 
s pr.2 P            
p i.po {p-op92-3}

# restore contents of MEM13
$clear {p-op92-3} a13 {t-op92-3} {p-op92-4}

$storeex {p-op92-4}
$rec {p-op92-4} a13 {t-op92-4} {i-main} {p-fetch}


# - HALT -
# Wire halt to quit the simulator so we can run programs and exit when they're
# done.
# p {p-op95} debug.quit


# -- ACCUMULATOR DECODE --
# lookup table used to trigger accumulators on loadacc / storeacc
# This is on FT3 but doesn't conflict with FTL values since it uses 10 of 12 digits
defmacro acc-decode-line line x01 x02 x03 x04 x05 x06 x07 x08 x09 x10
  s f3.RA$lineL4 $x01
  s f3.RA$lineL3 $x02
  s f3.RA$lineL2 $x03
  s f3.RA$lineL1 $x04
  s f3.RB$lineL6 $x05
  s f3.RB$lineL5 $x06
  s f3.RB$lineL4 $x07
  s f3.RB$lineL3 $x08
  s f3.RB$lineL2 $x09
  s f3.RB$lineL1 $x10
endmacro

$acc-decode-line 0  0 0 0 0 0 0 0 0 0 9
$acc-decode-line 1  0 0 0 0 0 0 0 0 9 0
$acc-decode-line 2  0 0 0 0 0 0 0 9 0 0
$acc-decode-line 3  0 0 0 0 0 0 9 0 0 0
$acc-decode-line 4  0 0 0 0 0 9 0 0 0 0
$acc-decode-line 5  0 0 0 0 9 0 0 0 0 0
$acc-decode-line 6  0 0 0 9 0 0 0 0 0 0
$acc-decode-line 7  0 0 9 0 0 0 0 0 0 0
$acc-decode-line 8  0 9 0 0 0 0 0 0 0 0
$acc-decode-line 9  9 0 0 0 0 0 0 0 0 0  


# -- CURRENT PROGRAM --
include ftdata.easm

# Start the machine
b i
